# Chapter 06

## DI 와 서비스 로케이터
추상화 된 클래스 (상위 클래스)에 대한 다양한 콘크리트 클래스(하위 클래스)가 존재할 때, 프로그램 내에서 사용할 콘크리트 클래스(하위 클래스)를 제공하는 책임을 갖는 객체가 필요하다. <br>

서비스 로케이터와 DI를 통해 위 책임을 갖는 객체를 제공할 수 있다.
- 서비스 로케이터 방식
  - `LOCATOR` 를 통해서 필요로 하는 객체를 직접 찾는 방식
  
- DI 방식 (Dependency Injection)
  - 외부에서 사용할 객체를 주입해주는 방식으로 필요한 객체를 직접 생성하거나 찾지 않는다.
  - Spring Framework에서 지원하는 방식으로, 일반적으로 서비스 로케이터 방식보다는 DI 방식을 이용한다. 

### 어플리케이션 영역 vs 메인 영역
소프트웨어에서 구분되는 두 개의 영역
- **어플리케이션 영역** : 고수준 정책 및 저수준 구현을 포함
- **메인 영역** : 어플리케이션이 동작하도록 각 객체들을 연결해주는 역할<br>
  DI와 서비스 로케이터는 메인 영역에서 객체 연결을 위해 사용되는 방법.<br>
  자바의 main메소드
  - 어플리케이션 영역에서 사용될 객체 생성
  - 각 객체 간의 의존곤계 설정
  - 어플리케이션 실행

모든 의존은 메인영역 > 어플리케이션 영역으로 향함

### DI
- Q. 왜 DI를 이용할까?
  - 사용할 객체를 직접 생성할 경우, 콘크리트 클래스에 대한 의존이 발생하여 DIP를 위반하게 됨.
  ```java
  public class Worker {
    public void run() {
        JobQueue jobQueue = new FileJobQueue(); // DIP 위반
    }
  }
    ```

**의존하는 객체를 전달받을 수 있는 방법**을 제공하여 DI를 적용할 수 있다.

DI를 통해서 의존 객체를 관리할 때 필요한 기능은 아래와 같고, 조립기를 분리하여 구현 변경에 유연함을 얻을 수 있다.
1. 객체 생성해주는 기능
2. 의존 관계에 따라 연결해주는 조립기능(조립기)

DI를 적용하는 방식에는 두 가지 방법이 있다.
- 생성자를 이용한 방식
  - 생성자를 통해서 의존 객체를 전달받는 방식
  - 객체를 생성하는 시점에서 의존 객체가 정상인지 확인할 수 있기 때문에 runtime exception 확률이 감소한다. 주로 이 방식을 사용
- 설정메서드(Setter)를 이용한 방식
  - 메서드를 이용해서 의존 객체를 전달받는 방식
  - 주로 자바빈프로퍼티규약에 따라 리턴타입 void인 setter 메서드를 이용하지만, 리턴타입을 변경하기도 함(?) 
  - 객체 생성 시점에서는 의존 객체에 대해 알 수 없기 때문에 NPE 발생할 확률이 높다. 
  - 특정 이유로 의존 객체가 나중에 생성될 때 위 방법을 고려할 수 있다. 
  - 의존할 객체가 많은 경우, 메서드 이름을 통해서 어떤 의존 객체가 생성되는 지 알기 쉬운 이유로 가독성에 좋다.


### 서비스 로케이터
안드로이드 처럼 DI 패턴 적용이 어려운 경우 의존 객체를 제공하기 위해 서비스 로케이터 방식을 취한다.

단점
- 인터페이스 분리 원칙 위배
- 동일 타입의 객체가 다수 필요할 경우, 각 객체 별로 제공 메서드 생성필요