# Chapter 01

소프트웨어는 요구 사항의 변경에 유연하게 대처해야 가치가 있다.<br>
객체 지향 설계를 통해 수정하기 좋은 코드를 생성하자

[ 수정하기 좋은 코드 ]
- 기능 추가 시, 이전에 작성된 코드가 영향을 받지 않는다.
- 하나의 기능에 관련된 코드가 한 클래스에 모여서 코드의 분석/수정이 용이하다.
- 서로 다른 기능에 대한 처리 코드가 섞여 있지 않아서 수정이 용이하다.
---

# Chapter 02
### 절차지향 vs 객체지향

**절차지향**
- 프로시저로 프로그램을 구성하는 기법
- 순서에 따라 프로그래밍을 하는 것이 아닌 데이터를 중심으로 구현한 프로그래밍 기법
- 모든 프로시저가 데이터를 공유하는 특징을 지님

**객체지향**
- 데이터 및 데이터와 관련된 프로시저를 **객체** 단위로 묶고
- 객체들의 연결로 프로그램을 수정함
- 규모가 작은 프로그램에선 절차 지향 방식보다 복잡한 구조가 되어 불리
- 객체의 데이터 변경 시 해당 객체로만 변화가 집중되고 다른 객체에 영향을 주지 않음

### 객체
- 객체의 핵심은 기능(Operation)을 제공하는 것
- 객체의 물리적 특징: 객체 = 데이터 + 데이터를 조작하는 프로시저(오퍼레이션, 메서드, 함수)
- 오퍼레이션의 사용법 (Signature)
  - 기능 식별 이름
  - 파라미터 및 파라미터 타입
  - 기능 실행 결과 값
- 인터페이스
  - 오퍼레이션 집합
  - 객체를 사용하기 위한 일종의 명세나 규칙
- 클래스
  - 실제 객체의 기능을 구현
- 메시지
  - 한 객체가 다른 객체의 오퍼레이션 실행을 요청하는 것
  - 자바에서는 한 객체 내에서 다른 객체의 메서드를 호출하는 것이 메시지를 보내는 것

### 객체의 책임과 크기
- 객체의 기능 = 객체의 책임
- 한 객체에 많은 기능이 포함되면 그 기능과 관련된 데이터들도 한 객체에 모두 포함되고, 데이터를 공유하는 객체의 범위가 커지게 되어 절차지향방식이 되어버림.
- 객체의 책임이 작아질수록 변경의 유연함을 얻을 수 있음.
- 하나의 객체는 한 가지의 책임을 지녀야 한다.(단일 책임 원칙)

### 의존
- 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존한다고 표현함
- 잘못된 구현은 순환의존이 발생할 수 있는데 의존 역전 원칙을 통해 이를 방지한다
  - [순환 의존] A 클래스 -> B 클래스 -> C 클래스 -> A 클래스
  
### 캡슐화
- 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것
- 내부 기능 구현이 변경되더라도, 외부에서 그 기능을 사용하는 코드는 영향을 받지 않음. 즉, 내부 구현 변경의 유연함을 줌
- 캡슐화 사용을 위한 두 개의 규칙
  - Tell, Don't Ask: 데이터를 묻지 말고, 기능을 실행해달라고 말하라
    - 기능 실행을 요청하는 방식의 코드 작성은, 자연스럽게 기능 구현에 대한 상세가 감춰지게 되어 객체의 캡슐화가 이루어짐
  - Law of Demeter
    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출
    ```
      member.getDate().getTime(); -> member.someMethod();
    ```
    
### 객체 지향 설계
1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능에 알맞은 객체에 할당한다.
   1. 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다.
   2. 기능은 최대한 캡슐화해서 구현한다
2. 객체 간에 어떻게 메시지를 주고 받을 지 결정한다.
3. 1,2를 반복한다.

객체 설계는 한 번에 완성되지 않고, 구현을 진행해 나가면서 점신적으로 완성된다.<br>
개발이 진행되면서 설계가 함께 변경될 수 있는 것을 고려하여 유연한 구조를 갖도록 노력하자.